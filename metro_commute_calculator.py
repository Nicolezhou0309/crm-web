#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ä¸Šæµ·åœ°é“é€šå‹¤æ—¶é—´è®¡ç®—å·¥å…·ï¼ˆç²¾ç®€ç‰ˆï¼‰
åŸºäºDijkstraç®—æ³•å®ç°æœ€ä¼˜è·¯çº¿æŸ¥æ‰¾ï¼Œæ”¯æŒå¤šçº§æ¢ä¹˜
"""

import heapq
from collections import defaultdict
from typing import Dict, List, Tuple

class MetroCommuteCalculator:
    def __init__(self):
        """åˆå§‹åŒ–åœ°é“çº¿è·¯å’Œæ¢ä¹˜ä¿¡æ¯"""
        self.lines = {
            '1å·çº¿': ['è˜åº„', 'å¤–ç¯è·¯', 'è²èŠ±è·¯', 'é”¦æ±Ÿä¹å›­', 'ä¸Šæµ·å—ç«™', 'æ¼•å®è·¯', 'ä¸Šæµ·ä½“è‚²é¦†', 'å¾å®¶æ±‡', 'è¡¡å±±è·¯', 'å¸¸ç†Ÿè·¯', 'é™•è¥¿å—è·¯', 'ä¸€å¤§ä¼šå€Â·é»„é™‚å—è·¯', 'äººæ°‘å¹¿åœº', 'æ–°é—¸è·¯', 'æ±‰ä¸­è·¯', 'ä¸Šæµ·ç«è½¦ç«™', 'ä¸­å±±åŒ—è·¯', 'å»¶é•¿è·¯', 'ä¸Šæµ·é©¬æˆåŸ', 'æ±¶æ°´è·¯', 'å½­æµ¦æ–°æ‘', 'å…±åº·è·¯', 'é€šæ²³æ–°æ‘', 'å‘¼å…°è·¯', 'å…±å¯Œæ–°æ‘', 'å®å®‰å…¬è·¯', 'å‹è°Šè¥¿è·¯', 'å¯Œé”¦è·¯'],
            '2å·çº¿': ['å›½å®¶ä¼šå±•ä¸­å¿ƒ', 'è™¹æ¡¥ç«è½¦ç«™', 'è™¹æ¡¥2å·èˆªç«™æ¥¼', 'æ·è™¹è·¯', 'åŒ—æ–°æ³¾', 'å¨å®è·¯', 'å¨„å±±å…³è·¯', 'ä¸­å±±å…¬å›­', 'æ±Ÿè‹è·¯', 'é™å®‰å¯º', 'å—äº¬è¥¿è·¯', 'äººæ°‘å¹¿åœº', 'å—äº¬ä¸œè·¯', 'é™†å®¶å˜´', 'æµ¦ä¸œå—è·¯', 'ä¸–çºªå¤§é“', 'ä¸Šæµ·ç§‘æŠ€é¦†', 'ä¸–çºªå…¬å›­', 'é¾™é˜³è·¯', 'å¼ æ±Ÿé«˜ç§‘', 'é‡‘ç§‘è·¯', 'å¹¿å…°è·¯', 'å”é•‡', 'åˆ›æ–°ä¸­è·¯', 'åå¤ä¸œè·¯', 'å·æ²™', 'å‡Œç©ºè·¯', 'è¿œä¸œå¤§é“', 'æµ·å¤©ä¸‰è·¯', 'æµ¦ä¸œ1å·2å·èˆªç«™æ¥¼'],
            '3å·çº¿': ['ä¸Šæµ·å—ç«™', 'çŸ³é¾™è·¯', 'é¾™æ¼•è·¯', 'æ¼•æºªè·¯', 'å®œå±±è·¯', 'è™¹æ¡¥è·¯', 'å»¶å®‰è¥¿è·¯', 'ä¸­å±±å…¬å›­', 'é‡‘æ²™æ±Ÿè·¯', 'æ›¹æ¨è·¯', 'é•‡åªè·¯', 'ä¸­æ½­è·¯', 'ä¸Šæµ·ç«è½¦ç«™', 'å®å±±è·¯', 'ä¸œå®å…´è·¯', 'è™¹å£è¶³çƒåœº', 'èµ¤å³°è·¯', 'å¤§æŸæ ‘', 'æ±Ÿæ¹¾é•‡', 'æ®·é«˜è¥¿è·¯', 'é•¿æ±Ÿå—è·¯', 'æ·å‘è·¯', 'å¼ åæµœ', 'æ·æ»¨è·¯', 'æ°´äº§è·¯', 'å®æ¨è·¯', 'å‹è°Šè·¯', 'é“åŠ›è·¯', 'æ±Ÿæ¨åŒ—è·¯'],
            '4å·çº¿': ['å®œå±±è·¯', 'è™¹æ¡¥è·¯', 'å»¶å®‰è¥¿è·¯', 'ä¸­å±±å…¬å›­', 'é‡‘æ²™æ±Ÿè·¯', 'æ›¹æ¨è·¯', 'é•‡åªè·¯', 'ä¸­æ½­è·¯', 'ä¸Šæµ·ç«è½¦ç«™', 'å®å±±è·¯', 'æµ·ä¼¦è·¯', 'ä¸´å¹³è·¯', 'å¤§è¿è·¯', 'æ¨æ ‘æµ¦è·¯', 'æµ¦ä¸œå¤§é“', 'ä¸–çºªå¤§é“', 'å‘åŸè·¯', 'è“æ‘è·¯', 'å¡˜æ¡¥', 'å—æµ¦å¤§æ¡¥', 'è¥¿è—å—è·¯', 'é²ç­è·¯', 'å¤§æœ¨æ¡¥è·¯', 'ä¸œå®‰è·¯', 'ä¸Šæµ·ä½“è‚²åœº', 'ä¸Šæµ·ä½“è‚²é¦†'],
            '5å·çº¿': ['è˜åº„', 'æ˜¥ç”³è·¯', 'é“¶éƒ½è·¯', 'é¢›æ¡¥', 'åŒ—æ¡¥', 'å‰‘å·è·¯', 'ä¸œå·è·¯', 'æ±Ÿå·è·¯', 'è¥¿æ¸¡', 'è§å¡˜', 'å¥‰æµ¦å¤§é“', 'ç¯åŸä¸œè·¯', 'æœ›å›­è·¯', 'é‡‘æµ·æ¹–', 'å¥‰è´¤æ–°åŸ', 'é‡‘å¹³è·¯', 'åå®è·¯', 'æ–‡äº•è·¯', 'é—µè¡Œå¼€å‘åŒº'],
            '6å·çº¿': ['ä¸œæ–¹ä½“è‚²ä¸­å¿ƒ', 'çµå²©å—è·¯', 'ä¸Šå—è·¯', 'åå¤è¥¿è·¯', 'é«˜é’è·¯', 'ä¸œæ˜è·¯', 'é«˜ç§‘è¥¿è·¯', 'ä¸´æ²‚æ–°æ‘', 'ä¸Šæµ·å„¿ç«¥åŒ»å­¦ä¸­å¿ƒ', 'è“æ‘è·¯', 'æµ¦ç”µè·¯', 'ä¸–çºªå¤§é“', 'æºæ·±ä½“è‚²ä¸­å¿ƒ', 'æ°‘ç”Ÿè·¯', 'åŒ—æ´‹æ³¾è·¯', 'å¾·å¹³è·¯', 'äº‘å±±è·¯', 'é‡‘æ¡¥è·¯', 'åšå…´è·¯', 'äº”è²è·¯', 'å·¨å³°è·¯', 'ä¸œé–è·¯', 'äº”æ´²å¤§é“', 'æ´²æµ·è·¯', 'å¤–é«˜æ¡¥ä¿ç¨åŒºå—', 'èˆªæ´¥è·¯', 'å¤–é«˜æ¡¥ä¿ç¨åŒºåŒ—', 'æ¸¯åŸè·¯'],
            '7å·çº¿': ['ç¾å…°æ¹–', 'ç½—å—æ–°æ‘', 'æ½˜å¹¿è·¯', 'åˆ˜è¡Œ', 'é¡¾æ‘å…¬å›­', 'ç¥åè·¯', 'ä¸Šæµ·å¤§å­¦', 'å—é™ˆè·¯', 'ä¸Šå¤§è·¯', 'åœºä¸­è·¯', 'å¤§åœºé•‡', 'è¡ŒçŸ¥è·¯', 'å¤§åä¸‰è·¯', 'æ–°æ‘è·¯', 'å²šçš‹è·¯', 'é•‡åªè·¯', 'é•¿å¯¿è·¯', 'æ˜Œå¹³è·¯', 'é™å®‰å¯º', 'å¸¸ç†Ÿè·¯', 'è‚‡å˜‰æµœè·¯', 'ä¸œå®‰è·¯', 'é¾™åä¸­è·¯', 'åæ»©', 'é•¿æ¸…è·¯', 'è€€åè·¯', 'äº‘å°è·¯', 'é«˜ç§‘è¥¿è·¯', 'æ¨é«˜å—è·¯', 'é”¦ç»£è·¯', 'èŠ³åè·¯', 'é¾™é˜³è·¯', 'èŠ±æœ¨è·¯'],
            '8å·çº¿': ['æ²ˆæœå…¬è·¯', 'è”èˆªè·¯', 'æ±Ÿæœˆè·¯', 'æµ¦æ±Ÿé•‡', 'èŠ¦æ’è·¯', 'å‡Œå…†æ–°æ‘', 'ä¸œæ–¹ä½“è‚²ä¸­å¿ƒ', 'æ¨æ€', 'æˆå±±è·¯', 'è€€åè·¯', 'ä¸­åè‰ºæœ¯å®«', 'è¥¿è—å—è·¯', 'é™†å®¶æµœè·¯', 'è€è¥¿é—¨', 'å¤§ä¸–ç•Œ', 'äººæ°‘å¹¿åœº', 'æ›²é˜œè·¯', 'ä¸­å…´è·¯', 'è¥¿è—åŒ—è·¯', 'è™¹å£è¶³çƒåœº', 'æ›²é˜³è·¯', 'å››å¹³è·¯', 'éå±±æ–°æ‘', 'æ±Ÿæµ¦è·¯', 'é»„å…´è·¯', 'å»¶å‰ä¸­è·¯', 'é»„å…´å…¬å›­', 'ç¿”æ®·è·¯', 'å«©æ±Ÿè·¯', 'å¸‚å…‰è·¯'],
            '9å·çº¿': ['ä¸Šæµ·æ¾æ±Ÿç«™', 'é†‰ç™½æ± ', 'æ¾æ±Ÿä½“è‚²ä¸­å¿ƒ', 'æ¾æ±Ÿæ–°åŸ', 'æ¾æ±Ÿå¤§å­¦åŸ', 'æ´æ³¾', 'ä½˜å±±', 'æ³—æ³¾', 'ä¹äº­', 'ä¸­æ˜¥è·¯', 'ä¸ƒå®', 'æ˜Ÿä¸­è·¯', 'åˆå·è·¯', 'æ¼•æ²³æ³¾å¼€å‘åŒº', 'æ¡‚æ—è·¯', 'å®œå±±è·¯', 'å¾å®¶æ±‡', 'è‚‡å˜‰æµœè·¯', 'å˜‰å–„è·¯', 'æ‰“æµ¦æ¡¥', 'é©¬å½“è·¯', 'é™†å®¶æµœè·¯', 'å°å—é—¨', 'å•†åŸè·¯', 'ä¸–çºªå¤§é“', 'æ¨é«˜ä¸­è·¯', 'èŠ³ç”¸è·¯', 'è“å¤©è·¯', 'å°å„¿åº„è·¯', 'é‡‘æ¡¥', 'é‡‘å‰è·¯', 'é‡‘æµ·è·¯', 'é¡¾å”è·¯', 'æ°‘é›·è·¯', 'æ›¹è·¯'],
            '10å·çº¿': ['èˆªä¸­è·¯', 'ç´«è—¤è·¯', 'é¾™æŸæ–°æ‘', 'è™¹æ¡¥ç«è½¦ç«™', 'è™¹æ¡¥2å·èˆªç«™æ¥¼', 'è™¹æ¡¥1å·èˆªç«™æ¥¼', 'ä¸Šæµ·åŠ¨ç‰©å›­', 'é¾™æºªè·¯', 'æ°´åŸè·¯', 'ä¼ŠçŠè·¯', 'å®‹å›­è·¯', 'è™¹æ¡¥è·¯', 'äº¤é€šå¤§å­¦', 'ä¸Šæµ·å›¾ä¹¦é¦†', 'é™•è¥¿å—è·¯', 'ä¸€å¤§ä¼šå€Â·æ–°å¤©åœ°', 'è€è¥¿é—¨', 'è±«å›­', 'å—äº¬ä¸œè·¯', 'å¤©æ½¼è·¯', 'å››å·åŒ—è·¯', 'æµ·ä¼¦è·¯', 'é‚®ç”µæ–°æ‘', 'å››å¹³è·¯', 'åŒæµå¤§å­¦', 'å›½æƒè·¯', 'äº”è§’åœº', 'æ±Ÿæ¹¾ä½“è‚²åœº', 'ä¸‰é—¨è·¯', 'æ®·é«˜ä¸œè·¯', 'æ–°æ±Ÿæ¹¾åŸ', 'å›½å¸†è·¯', 'åŒæ±Ÿè·¯', 'é«˜æ¡¥è¥¿', 'é«˜æ¡¥', 'æ¸¯åŸè·¯', 'åŸºéš†è·¯'],
            '11å·çº¿': ['èŠ±æ¡¥', 'å…‰æ˜è·¯', 'å…†ä¸°è·¯', 'å®‰äº­', 'ä¸Šæµ·æ±½è½¦åŸ', 'æ˜Œå‰ä¸œè·¯', 'ä¸Šæµ·èµ›è½¦åœº', 'å˜‰å®šåŒ—', 'å˜‰å®šè¥¿', 'ç™½é“¶è·¯', 'å˜‰å®šæ–°åŸ', 'é©¬é™†', 'é™ˆç¿”å…¬è·¯', 'å—ç¿”', 'æ¡ƒæµ¦æ–°æ‘', 'æ­¦å¨è·¯', 'ç¥è¿å±±è·¯', 'æå­å›­', 'ä¸Šæµ·è¥¿ç«™', 'çœŸå¦‚', 'æ«æ¡¥è·¯', 'æ›¹æ¨è·¯', 'éš†å¾·è·¯', 'æ±Ÿè‹è·¯', 'äº¤é€šå¤§å­¦', 'å¾å®¶æ±‡', 'ä¸Šæµ·æ¸¸æ³³é¦†', 'é¾™å', 'äº‘é”¦è·¯', 'é¾™è€€è·¯', 'ä¸œæ–¹ä½“è‚²ä¸­å¿ƒ', 'ä¸‰æ—', 'ä¸‰æ—ä¸œ', 'æµ¦ä¸‰è·¯', 'åº·æ’è·¯', 'å¾¡æ¡¥', 'ç½—å±±è·¯', 'ç§€æ²¿è·¯', 'åº·æ–°å…¬è·¯', 'è¿ªå£«å°¼'],
            '12å·çº¿': ['ä¸ƒè˜è·¯', 'è™¹è˜è·¯', 'é¡¾æˆ´è·¯', 'ä¸œå…°è·¯', 'è™¹æ¢…è·¯', 'è™¹æ¼•è·¯', 'æ¡‚æ—å…¬å›­', 'æ¼•å®è·¯', 'é¾™æ¼•è·¯', 'é¾™å', 'é¾™åä¸­è·¯', 'å¤§æœ¨æ¡¥è·¯', 'å˜‰å–„è·¯', 'é™•è¥¿å—è·¯', 'å—äº¬è¥¿è·¯', 'æ±‰ä¸­è·¯', 'æ›²é˜œè·¯', 'å¤©æ½¼è·¯', 'å›½é™…å®¢è¿ä¸­å¿ƒ', 'æç¯®æ¡¥', 'å¤§è¿è·¯', 'æ±Ÿæµ¦å…¬å›­', 'å®å›½è·¯', 'éš†æ˜Œè·¯', 'çˆ±å›½è·¯', 'å¤å…´å²›', 'ä¸œé™†è·¯', 'å·¨å³°è·¯', 'æ¨é«˜åŒ—è·¯', 'é‡‘äº¬è·¯', 'ç”³æ±Ÿè·¯', 'é‡‘æµ·è·¯'],
            '13å·çº¿': ['é‡‘è¿è·¯', 'é‡‘æ²™æ±Ÿè¥¿è·¯', 'ä¸°åº„', 'ç¥è¿å±±å—è·¯', 'çœŸåŒ—è·¯', 'å¤§æ¸¡æ²³è·¯', 'é‡‘æ²™æ±Ÿè·¯', 'éš†å¾·è·¯', 'æ­¦å®è·¯', 'é•¿å¯¿è·¯', 'æ±Ÿå®è·¯', 'æ±‰ä¸­è·¯', 'è‡ªç„¶åšç‰©é¦†', 'å—äº¬è¥¿è·¯', 'æ·®æµ·ä¸­è·¯', 'ä¸€å¤§ä¼šå€Â·æ–°å¤©åœ°', 'é©¬å½“è·¯', 'ä¸–åšä¼šåšç‰©é¦†', 'ä¸–åšå¤§é“', 'é•¿æ¸…è·¯', 'æˆå±±è·¯', 'ä¸œæ˜è·¯', 'åé¹è·¯', 'ä¸‹å—è·¯', 'åŒ—è”¡', 'é™ˆæ˜¥è·¯', 'è²æºªè·¯', 'åå¤ä¸­è·¯', 'ä¸­ç§‘è·¯', 'å­¦æ—è·¯', 'å¼ æ±Ÿè·¯'],
            '14å·çº¿': ['å°æµœ', 'ä¹ç§€è·¯', 'ä¸´æ´®è·¯', 'å˜‰æ€¡è·¯', 'å®šè¾¹è·¯', 'çœŸæ–°æ–°æ‘', 'çœŸå…‰è·¯', 'é“œå·è·¯', 'çœŸå¦‚', 'ä¸­å®è·¯', 'æ›¹æ¨è·¯', 'æ­¦å®è·¯', 'æ­¦å®šè·¯', 'é™å®‰å¯º', 'ä¸€å¤§ä¼šå€Â·é»„é™‚å—è·¯', 'å¤§ä¸–ç•Œ', 'è±«å›­', 'é™†å®¶å˜´', 'æµ¦ä¸œå—è·¯', 'æµ¦ä¸œå¤§é“', 'æºæ·±è·¯', 'æ˜Œé‚‘è·¯', 'æ­‡æµ¦è·¯', 'äº‘å±±è·¯', 'è“å¤©è·¯', 'é»„æ¨è·¯', 'äº‘é¡ºè·¯', 'æµ¦ä¸œè¶³çƒåœº', 'é‡‘ç²¤è·¯', 'æ¡‚æ¡¥è·¯'],
            '15å·çº¿': ['ç´«ç«¹é«˜æ–°åŒº', 'æ°¸å¾·è·¯', 'å…ƒæ±Ÿè·¯', 'åŒæŸè·¯', 'æ›™å»ºè·¯', 'æ™¯è¥¿è·¯', 'è™¹æ¢…å—è·¯', 'æ™¯æ´ªè·¯', 'æœ±æ¢…è·¯', 'ç½—ç§€è·¯', 'åä¸œç†å·¥å¤§å­¦', 'ä¸Šæµ·å—ç«™', 'æ¡‚æ—å…¬å›­', 'æ¡‚æ—è·¯', 'å´ä¸­è·¯', 'å§šè™¹è·¯', 'çº¢å®çŸ³è·¯', 'å¨„å±±å…³è·¯', 'é•¿é£å…¬å›­', 'å¤§æ¸¡æ²³è·¯', 'æ¢…å²­åŒ—è·¯', 'é“œå·è·¯', 'ä¸Šæµ·è¥¿ç«™', 'æ­¦å¨ä¸œè·¯', 'å¤æµªè·¯', 'ç¥å®‰è·¯', 'å—å¤§è·¯', 'ä¸°ç¿”è·¯', 'é”¦ç§‹è·¯', 'é¡¾æ‘å…¬å›­'],
            '16å·çº¿': ['é¾™é˜³è·¯', 'åå¤ä¸­è·¯', 'ç½—å±±è·¯', 'å‘¨æµ¦ä¸œ', 'é¹¤æ²™èˆªåŸ', 'èˆªå¤´ä¸œ', 'æ–°åœº', 'é‡ç”ŸåŠ¨ç‰©å›­', 'æƒ å—', 'æµ¦ä¸œç«è½¦ç«™', 'ä¹¦é™¢', 'ä¸´æ¸¯å¤§é“', 'æ»´æ°´æ¹–'],
            '17å·çº¿': ['è™¹æ¡¥ç«è½¦ç«™', 'å›½å®¶ä¼šå±•ä¸­å¿ƒ', 'èŸ é¾™è·¯', 'å¾ç›ˆè·¯', 'å¾æ³¾åŒ—åŸ', 'å˜‰æ¾ä¸­è·¯', 'èµµå··', 'æ±‡é‡‘è·¯', 'é’æµ¦æ–°åŸ', 'æ¼•ç›ˆè·¯', 'æ·€å±±æ¹–å¤§é“', 'æœ±å®¶è§’', 'ä¸œæ–¹ç»¿èˆŸ', 'è¥¿å²‘'],
            '18å·çº¿': ['èˆªå¤´', 'ä¸‹æ²™', 'é¹¤æ¶›è·¯', 'æ²ˆæ¢…è·¯', 'ç¹è£è·¯', 'å‘¨æµ¦', 'åº·æ¡¥', 'å¾¡æ¡¥', 'è²æºªè·¯', 'åŒ—ä¸­è·¯', 'èŠ³èŠ¯è·¯', 'é¾™é˜³è·¯', 'è¿æ˜¥è·¯', 'æ¨é«˜ä¸­è·¯', 'æ°‘ç”Ÿè·¯', 'æ˜Œé‚‘è·¯', 'ä¸¹é˜³è·¯', 'å¹³å‡‰è·¯', 'æ±Ÿæµ¦å…¬å›­', 'æ±Ÿæµ¦è·¯', 'æŠšé¡ºè·¯', 'å›½æƒè·¯', 'å¤æ—¦å¤§å­¦', 'ä¸Šæµ·è´¢ç»å¤§å­¦', 'æ®·é«˜è·¯', 'é•¿æ±Ÿå—è·¯']
        }
        
        # æ„å»ºæ¢ä¹˜ç«™ç‚¹æ˜ å°„å’Œé‚»æ¥å›¾
        self._build_transfer_mapping()
        self._build_adjacency_graph()
    
    def _build_transfer_mapping(self):
        """æ„å»ºæ¢ä¹˜ç«™ç‚¹æ˜ å°„"""
        self.transfer_stations = defaultdict(list)
        self.station_to_lines = defaultdict(list)
        
        # ç»Ÿè®¡æ¯ä¸ªç«™ç‚¹å‡ºç°åœ¨å“ªäº›çº¿è·¯ä¸Š
        for line_name, stations in self.lines.items():
            for station in stations:
                self.station_to_lines[station].append(line_name)
        
        # æ‰¾å‡ºæ¢ä¹˜ç«™ç‚¹ï¼ˆå‡ºç°åœ¨å¤šæ¡çº¿è·¯ä¸Šçš„ç«™ç‚¹ï¼‰
        for station, lines_list in self.station_to_lines.items():
            if len(lines_list) > 1:
                self.transfer_stations[station] = lines_list
    
    def _build_adjacency_graph(self):
        """æ„å»ºé‚»æ¥å›¾ï¼ŒåŒ…å«ç«™ç‚¹é—´è·ç¦»"""
        self.graph = defaultdict(list)
        
        # ä¸ºæ¯æ¡çº¿è·¯æ„å»ºé‚»æ¥å…³ç³»
        for line_name, stations in self.lines.items():
            for i, station in enumerate(stations):
                # æ·»åŠ ç›¸é‚»ç«™ç‚¹ï¼ˆ3åˆ†é’Ÿä¸€ç«™ï¼‰
                if i > 0:
                    prev_station = stations[i-1]
                    self.graph[station].append((prev_station, 3, line_name))
                if i < len(stations) - 1:
                    next_station = stations[i+1]
                    self.graph[station].append((next_station, 3, line_name))
    
    def find_route(self, start_station: str, end_station: str) -> Dict:
        """
        æŸ¥æ‰¾ä»èµ·å§‹ç«™åˆ°ç»ˆç‚¹ç«™çš„æœ€ä¼˜è·¯çº¿
        ä½¿ç”¨Dijkstraç®—æ³•æ‰¾åˆ°å…¨å±€æœ€ä¼˜è·¯å¾„
        """
        if start_station not in self.station_to_lines:
            return {'success': False, 'error': f'èµ·å§‹ç«™ {start_station} ä¸å­˜åœ¨'}
        
        if end_station not in self.station_to_lines:
            return {'success': False, 'error': f'ç»ˆç‚¹ç«™ {end_station} ä¸å­˜åœ¨'}
        
        # ä½¿ç”¨Dijkstraç®—æ³•æ‰¾æœ€çŸ­è·¯å¾„
        distances, previous, lines_used = self._dijkstra(start_station)
        
        if end_station not in distances:
            return {'success': False, 'error': f'æ— æ³•æ‰¾åˆ°ä» {start_station} åˆ° {end_station} çš„è·¯çº¿'}
        
        # é‡å»ºè·¯å¾„
        path, transfers = self._reconstruct_path(start_station, end_station, previous, lines_used)
        
        # è®¡ç®—æ€»æ—¶é—´ï¼šç«™ç‚¹é—´æ—¶é—´ + æ¢ä¹˜æ—¶é—´
        total_time = distances[end_station] + (len(transfers) * 5)
        
        return {
            'success': True,
            'start_station': start_station,
            'end_station': end_station,
            'total_time_minutes': total_time,
            'total_time_formatted': f'{total_time}åˆ†é’Ÿ',
            'stations_count': len(path) - 1,
            'path': path,
            'transfers': transfers,
            'transfer_count': len(transfers),
            'route_summary': self._generate_route_summary(start_station, end_station, path, transfers, lines_used)
        }
    
    def _dijkstra(self, start_station: str) -> Tuple[Dict[str, int], Dict[str, str], Dict[str, str]]:
        """
        Dijkstraç®—æ³•å®ç°
        è¿”å›ï¼šè·ç¦»å­—å…¸ã€å‰é©±èŠ‚ç‚¹å­—å…¸ã€ä½¿ç”¨çš„çº¿è·¯å­—å…¸
        """
        distances = {station: float('inf') for station in self.station_to_lines}
        distances[start_station] = 0
        
        previous = {}
        lines_used = {}
        
        # ä¼˜å…ˆé˜Ÿåˆ—ï¼š(è·ç¦», ç«™ç‚¹)
        pq = [(0, start_station)]
        visited = set()
        
        while pq:
            current_distance, current_station = heapq.heappop(pq)
            
            if current_station in visited:
                continue
            
            visited.add(current_station)
            
            # éå†æ‰€æœ‰ç›¸é‚»ç«™ç‚¹
            for neighbor, weight, line_info in self.graph[current_station]:
                if neighbor in visited:
                    continue
                
                new_distance = current_distance + weight
                
                if new_distance < distances[neighbor]:
                    distances[neighbor] = new_distance
                    previous[neighbor] = current_station
                    lines_used[neighbor] = line_info
                    heapq.heappush(pq, (new_distance, neighbor))
        
        return distances, previous, lines_used
    
    def _reconstruct_path(self, start_station: str, end_station: str, 
                         previous: Dict[str, str], lines_used: Dict[str, str]) -> Tuple[List[str], List[Dict]]:
        """é‡å»ºè·¯å¾„å’Œæ¢ä¹˜ä¿¡æ¯"""
        path = []
        transfers = []
        current = end_station
        
        # ä»ç»ˆç‚¹å›æº¯åˆ°èµ·ç‚¹
        while current is not None:
            path.append(current)
            current = previous.get(current)
        
        path.reverse()
        
        # åˆ†ææ¢ä¹˜ä¿¡æ¯
        current_line = None
        for i in range(len(path) - 1):
            current_station = path[i]
            next_station = path[i + 1]
            
            # å°è¯•ä»ç«™ç‚¹æ¨æ–­çº¿è·¯
            found_line = None
            for line_name, stations in self.lines.items():
                if current_station in stations and next_station in stations:
                    found_line = line_name
                    break
            
            if found_line:
                if current_line and current_line != found_line:
                    # å‘ç°æ¢ä¹˜
                    transfers.append({
                        'station': current_station,
                        'from_line': current_line,
                        'to_line': found_line
                    })
                current_line = found_line
        
        return path, transfers
    
    def _generate_route_summary(self, start_station: str, end_station: str, 
                               path: List[str], transfers: List[Dict], lines_used: Dict[str, str]) -> str:
        """ç”Ÿæˆè·¯çº¿æ‘˜è¦"""
        if not transfers:
            # æ— éœ€æ¢ä¹˜ï¼Œæ‰¾åˆ°èµ·å§‹ç«™å’Œç»ˆç‚¹ç«™æ‰€åœ¨çš„çº¿è·¯
            for line_name, stations in self.lines.items():
                if start_station in stations and end_station in stations:
                    return f'ä» {start_station} ä¹˜å{line_name}åˆ° {end_station}ï¼Œæ— éœ€æ¢ä¹˜'
            return f'ä» {start_station} åˆ° {end_station}ï¼Œæ— éœ€æ¢ä¹˜'
        
        # æœ‰æ¢ä¹˜çš„æƒ…å†µ
        # é¦–å…ˆæ‰¾åˆ°èµ·å§‹ç«™æ‰€åœ¨çš„çº¿è·¯
        start_line = None
        for line_name, stations in self.lines.items():
            if start_station in stations:
                start_line = line_name
                break
        
        summary_parts = [f'ä» {start_station} ä¹˜å{start_line}']
        
        for transfer in transfers:
            summary_parts.append(f'åœ¨{transfer["station"]}æ¢ä¹˜{transfer["to_line"]}')
        
        summary_parts.append(f'åˆ°è¾¾{end_station}')
        
        return 'ï¼Œ'.join(summary_parts)
    
    def calculate_commute_time(self, start_station: str, end_station: str) -> Dict:
        """è®¡ç®—é€šå‹¤æ—¶é—´ï¼ˆå…¼å®¹æ¥å£ï¼‰"""
        return self.find_route(start_station, end_station)

def main():
    """ä¸»å‡½æ•° - ç®€å•çš„ä½¿ç”¨ç¤ºä¾‹"""
    calculator = MetroCommuteCalculator()
    
    print("ä¸Šæµ·åœ°é“é€šå‹¤æ—¶é—´è®¡ç®—å·¥å…·")
    print("=" * 50)
    
    # ç¤ºä¾‹ï¼šæµ¦ä¸œ1å·2å·èˆªç«™æ¥¼åˆ°è¿ªå£«å°¼
    start_station = "æµ¦ä¸œ1å·2å·èˆªç«™æ¥¼"
    end_station = "è¿ªå£«å°¼"
    
    result = calculator.find_route(start_station, end_station)
    
    if result['success']:
        print(f"âœ… {start_station} â†’ {end_station}: {result['total_time_formatted']}")
        print(f"ğŸ“Š {result['stations_count']}ç«™, {result['transfer_count']}æ¬¡æ¢ä¹˜")
        print(f"ğŸ“ {result['route_summary']}")
    else:
        print(f"âŒ {result['error']}")

if __name__ == "__main__":
    main()
