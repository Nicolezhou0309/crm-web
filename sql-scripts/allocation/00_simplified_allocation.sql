 -- 简化的线索分配系统
-- 目标：将复杂的分配逻辑简化为核心函数，减少代码复杂度
-- 执行顺序：0 (替代现有复杂系统)

-- =====================================
-- 0. 清理现有的表和函数
-- =====================================

-- 删除现有的分配相关表
DROP TABLE IF EXISTS public.allocation_logs CASCADE;
DROP TABLE IF EXISTS public.allocation_rules CASCADE;
DROP TABLE IF EXISTS public.user_conversion_rate_daily CASCADE;
DROP TABLE IF EXISTS public.duplicate_notifications CASCADE;
DROP TABLE IF EXISTS public.community_mapping_rules CASCADE;
DROP TABLE IF EXISTS public.quality_control_logs CASCADE;

-- 删除现有的触发器（必须在删除函数之前）
DROP TRIGGER IF EXISTS trg_before_insert_lead ON public.leads;
DROP TRIGGER IF EXISTS trg_after_insert_lead ON public.leads;
DROP TRIGGER IF EXISTS trg_after_insert_followup ON public.leads;
DROP TRIGGER IF EXISTS trigger_create_followup_on_lead_insert ON public.leads;

-- 使用CASCADE强制删除有依赖关系的函数
DROP FUNCTION IF EXISTS public.before_insert_lead() CASCADE;
DROP FUNCTION IF EXISTS public.after_insert_followup() CASCADE;
DROP FUNCTION IF EXISTS public.create_followup_on_lead_insert() CASCADE;
DROP FUNCTION IF EXISTS public.allocate_lead_enhanced() CASCADE;

-- 删除其他分配相关函数
DROP FUNCTION IF EXISTS public.execute_allocation(allocation_rule record, lead_id text);
DROP FUNCTION IF EXISTS public.execute_multi_group_allocation(allocation_rule record, lead_id text, lead_community community);
DROP FUNCTION IF EXISTS public.handle_duplicate_lead(new_leadid text, original_leadid text, phone text, wechat text, target_community community, manual_user_id bigint);
DROP FUNCTION IF EXISTS public.get_default_assignee();
DROP FUNCTION IF EXISTS public.check_time_range(time_ranges jsonb);
DROP FUNCTION IF EXISTS public.map_community_from_campaign(p_campaign_id text, p_campaign_name text, p_unit_id text, p_unit_name text, p_creative_id text, p_creative_name text, p_area text, p_location text);

-- =====================================
-- 1. 核心数据结构简化
-- =====================================

-- 1.1 确保allocation_method枚举类型存在
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'allocation_method') THEN
        CREATE TYPE allocation_method AS ENUM ('round_robin', 'random', 'workload');
    END IF;
END $$;

-- 1.2 创建或更新users_list表
CREATE TABLE IF NOT EXISTS public.users_list (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    groupname text,
    list bigint[],
    description text,
    created_at timestamptz NOT NULL DEFAULT NOW(),
    updated_at timestamptz DEFAULT NOW(),
    allocation allocation_method DEFAULT 'round_robin',
    
    -- 质量控制相关字段
    enable_quality_control boolean DEFAULT false,
    daily_lead_limit integer DEFAULT NULL,
    conversion_rate_requirement numeric(5,2) DEFAULT NULL,
    max_pending_leads integer DEFAULT NULL,
    quality_control_config jsonb DEFAULT NULL,
    
    -- 社区匹配控制字段
    enable_community_matching boolean DEFAULT true
);

-- 添加字段注释
COMMENT ON COLUMN public.users_list.enable_quality_control IS '是否启用质量控制';
COMMENT ON COLUMN public.users_list.daily_lead_limit IS '每日线索分配上限';
COMMENT ON COLUMN public.users_list.conversion_rate_requirement IS '30天转化率要求（百分比0-100）';
COMMENT ON COLUMN public.users_list.max_pending_leads IS '未接受线索数量上限';
COMMENT ON COLUMN public.users_list.quality_control_config IS '质量控制配置JSON，支持更复杂的规则';
COMMENT ON COLUMN public.users_list.enable_community_matching IS '是否启用社区匹配功能';

-- 创建索引和约束
CREATE INDEX IF NOT EXISTS idx_users_list_array_elements ON public.users_list USING gin (list);
CREATE INDEX IF NOT EXISTS idx_users_list_allocation ON public.users_list(allocation);
-- 移除部分唯一索引，改为完整唯一约束以支持 ON CONFLICT
-- CREATE UNIQUE INDEX IF NOT EXISTS idx_users_list_groupname_unique ON public.users_list(groupname) WHERE groupname IS NOT NULL;

-- 为新数据库添加必要的控制字段（如果表已存在）
ALTER TABLE public.users_list 
ADD COLUMN IF NOT EXISTS enable_quality_control boolean DEFAULT false,
ADD COLUMN IF NOT EXISTS daily_lead_limit integer DEFAULT NULL,
ADD COLUMN IF NOT EXISTS conversion_rate_requirement numeric(5,2) DEFAULT NULL,
ADD COLUMN IF NOT EXISTS max_pending_leads integer DEFAULT NULL,
ADD COLUMN IF NOT EXISTS quality_control_config jsonb DEFAULT NULL,
ADD COLUMN IF NOT EXISTS enable_community_matching boolean DEFAULT true,
ADD COLUMN IF NOT EXISTS allocation allocation_method DEFAULT 'round_robin';

-- 添加完整的唯一约束以支持 ON CONFLICT（可选）
DO $$
BEGIN
    -- 添加groupname的唯一约束（如果不存在且没有重复数据）
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.table_constraints 
        WHERE constraint_name = 'users_list_groupname_unique' 
        AND table_name = 'users_list'
        AND table_schema = 'public'
    ) THEN
        -- 检查是否有重复数据
        IF NOT EXISTS (
            SELECT groupname FROM users_list 
            WHERE groupname IS NOT NULL 
            GROUP BY groupname 
            HAVING COUNT(*) > 1
        ) THEN
            ALTER TABLE public.users_list 
            ADD CONSTRAINT users_list_groupname_unique UNIQUE (groupname);
            RAISE NOTICE '已添加 users_list.groupname 唯一约束';
        ELSE
            RAISE NOTICE '警告：users_list 表中存在重复的 groupname 值，无法添加唯一约束';
        END IF;
    ELSE
        RAISE NOTICE 'users_list.groupname 唯一约束已存在';
    END IF;
END $$;

-- 1.2 简化的分配规则表
CREATE OR REPLACE TABLE public.simple_allocation_rules (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    name text NOT NULL,
    description text,
    is_active boolean DEFAULT true,
    priority integer DEFAULT 0,
    
    -- 触发条件（简化）
    conditions jsonb DEFAULT '{}', -- 统一的条件配置
    
    -- 分配目标（简化）
    user_groups bigint[], -- 用户组数组，按顺序尝试
    allocation_method allocation_method DEFAULT 'round_robin',
    
    -- 功能开关（简化配置）
    enable_permission_check boolean DEFAULT false,
    
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now()
);

-- 1.2 简化的分配日志表
CREATE TABLE IF NOT EXISTS public.simple_allocation_logs (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    leadid text NOT NULL,
    rule_id uuid REFERENCES simple_allocation_rules(id),
    assigned_user_id bigint,
    
    -- 分配结果（简化）
    allocation_method text,
    selected_group_index integer, -- 选择了第几个用户组
    processing_details jsonb, -- 所有处理细节
    
    created_at timestamptz DEFAULT now()
);

-- 新增：社区关键词映射表
CREATE TABLE IF NOT EXISTS public.community_keywords (
  id serial PRIMARY KEY,
  keyword text[] NOT NULL,         -- 支持多个关键词
  community community NOT NULL,
  priority integer DEFAULT 0
);
-- =====================================
-- 2. 核心分配函数（统一所有逻辑）
-- =====================================

-- 修改 allocate_lead_simple 函数
CREATE OR REPLACE FUNCTION public.allocate_lead_simple(
    p_leadid text,
    p_source source DEFAULT NULL,
    p_leadtype text DEFAULT NULL,
    p_community community DEFAULT NULL,
    p_manual_user_id bigint DEFAULT NULL
) RETURNS jsonb
SECURITY DEFINER
SET search_path = public, pg_temp
AS $$
DECLARE
    rule_record RECORD;
    target_user_id bigint;
    processing_result jsonb;
    group_index integer;
    user_group_id bigint;
    candidate_users bigint[];
    final_users bigint[];
    allocation_details jsonb := '{}';
    group_allocation_method allocation_method;
    debug_info jsonb := '{}';
    rules_attempted integer := 0;
    rule_success boolean := false;
BEGIN
    -- 添加调试日志
    debug_info := jsonb_build_object(
        'input_leadid', p_leadid,
        'input_source', p_source,
        'input_leadtype', p_leadtype,
        'input_community', p_community,
        'input_manual_user_id', p_manual_user_id
    );
    
    -- 1. 手动分配优先
    IF p_manual_user_id IS NOT NULL THEN
        debug_info := debug_info || jsonb_build_object('manual_assignment', true);
        RETURN jsonb_build_object(
            'success', true,
            'assigned_user_id', p_manual_user_id,
            'allocation_method', 'manual',
            'processing_details', jsonb_build_object('manual_assignment', true),
            'debug_info', debug_info
        );
    END IF;
    
    -- 2. 按优先级顺序尝试所有匹配的规则
    FOR rule_record IN
        SELECT * FROM simple_allocation_rules
        WHERE is_active = true
          AND check_rule_conditions(conditions, p_source, p_leadtype, p_community)
        ORDER BY priority DESC, created_at ASC
    LOOP
        rules_attempted := rules_attempted + 1;
        
        -- 遍历规则中的用户组
        group_index := 1;
        FOREACH user_group_id IN ARRAY rule_record.user_groups
        LOOP
            -- 获取用户组中的用户列表
            candidate_users := get_group_users(user_group_id);
            
            -- 应用分配过滤器
            final_users := apply_allocation_filters(
                candidate_users,
                user_group_id,
                rule_record.enable_permission_check,
                true, -- 质量控制
                true, -- 社区匹配
                p_community
            );
            
            -- 如果有可用用户，尝试分配
            IF final_users IS NOT NULL AND array_length(final_users, 1) > 0 THEN
                -- 从users_list表获取分配方法，优先使用用户组配置
                SELECT allocation INTO group_allocation_method
                FROM users_list
                WHERE id = user_group_id;
                
                BEGIN
                    SELECT allocate_from_users(final_users, COALESCE(group_allocation_method, rule_record.allocation_method)) INTO target_user_id;
                    
                    IF target_user_id IS NOT NULL THEN
                        rule_success := true;
                        
                        -- 只在成功分配时记录一次日志
                        INSERT INTO simple_allocation_logs (
                            leadid, rule_id, assigned_user_id, allocation_method,
                            selected_group_index, processing_details
                        ) VALUES (
                            p_leadid, rule_record.id, target_user_id, rule_record.allocation_method,
                            group_index, jsonb_build_object(
                                'rule_name', rule_record.name,
                                'rule_priority', rule_record.priority,
                                'group_id', user_group_id,
                                'candidate_count', array_length(candidate_users, 1),
                                'final_count', array_length(final_users, 1),
                                'allocation_method', COALESCE(group_allocation_method, rule_record.allocation_method),
                                'rules_attempted', rules_attempted,
                                'filters_applied', jsonb_build_object(
                                    'permission_check', rule_record.enable_permission_check
                                ),
                                'debug_info', debug_info
                            )
                        );
                        
                        RETURN jsonb_build_object(
                            'success', true,
                            'assigned_user_id', target_user_id,
                            'allocation_method', rule_record.allocation_method,
                            'rule_name', rule_record.name,
                            'rule_priority', rule_record.priority,
                            'selected_group_index', group_index,
                            'rules_attempted', rules_attempted,
                            'processing_details', allocation_details,
                            'debug_info', debug_info
                        );
                    END IF;
                END;
            END IF;
            
            group_index := group_index + 1;
        END LOOP;
        
        EXIT WHEN rule_success;
    END LOOP;
    
    -- 如果没有成功分配，记录一次失败日志
    IF NOT rule_success THEN
        INSERT INTO simple_allocation_logs (
            leadid, processing_details
        ) VALUES (
            p_leadid,
            jsonb_build_object(
                'allocation_failed', true,
                'rules_attempted', rules_attempted,
                'debug_info', debug_info
            )
        );
    END IF;
    
    -- 返回分配失败结果
    RETURN jsonb_build_object(
        'success', false,
        'error', '无法找到合适的分配目标',
        'rules_attempted', rules_attempted,
        'debug_info', debug_info
    );
END;
$$;

-- =====================================
-- 3. 辅助函数（简化版本）
-- =====================================

-- 3.1 统一的条件检查函数
CREATE OR REPLACE FUNCTION public.check_rule_conditions(
    conditions jsonb,
    p_source source,
    p_leadtype text,
    p_community community
) RETURNS boolean
LANGUAGE plpgsql
AS $$
BEGIN
    -- 检查来源条件
    IF conditions ? 'sources' AND p_source IS NOT NULL THEN
        IF NOT (p_source::text = ANY(ARRAY(SELECT jsonb_array_elements_text(conditions->'sources')))) THEN
            RETURN false;
        END IF;
    END IF;
    
    -- 检查线索类型条件
    IF conditions ? 'lead_types' AND p_leadtype IS NOT NULL THEN
        IF NOT (p_leadtype = ANY(ARRAY(SELECT jsonb_array_elements_text(conditions->'lead_types')))) THEN
            RETURN false;
        END IF;
    END IF;
    
    -- 检查社区条件
    IF conditions ? 'communities' AND p_community IS NOT NULL THEN
        IF NOT (p_community::text = ANY(ARRAY(SELECT jsonb_array_elements_text(conditions->'communities')))) THEN
            RETURN false;
        END IF;
    END IF;
    
    -- 检查时间条件
    IF conditions ? 'time_ranges' THEN
        IF NOT check_time_condition(conditions->'time_ranges') THEN
            RETURN false;
        END IF;
    END IF;
    
    RETURN true;
END;
$$;

-- 修改 apply_allocation_filters 函数
CREATE OR REPLACE FUNCTION public.apply_allocation_filters(
    filtered_users bigint[],
    group_id bigint,
    enable_permission_check boolean DEFAULT false,
    enable_quality_control boolean DEFAULT true,
    enable_community_matching boolean DEFAULT true,
    p_community community DEFAULT NULL
) RETURNS bigint[]
LANGUAGE plpgsql
AS $$
DECLARE
    group_enable_quality boolean;
    group_enable_comm_match boolean;
    community_json jsonb;
    community_matched_users bigint[];
    dbg jsonb := '{}';
BEGIN
    -- 空数组直接返回
    IF filtered_users IS NULL OR array_length(filtered_users,1) IS NULL THEN
        RETURN NULL;
    END IF;

    -- 读取用户组配置
    SELECT 
        COALESCE(ul.enable_quality_control, false),
        COALESCE(ul.enable_community_matching, false)
    INTO
        group_enable_quality,
        group_enable_comm_match
    FROM users_list ul
    WHERE ul.id = group_id;
    
    -- 质量控制过滤
    IF group_enable_quality AND enable_quality_control THEN
        filtered_users := filter_users_by_quality_control(filtered_users, group_id);
        IF filtered_users IS NULL OR array_length(filtered_users,1) IS NULL THEN
            RETURN NULL;
        END IF;
    END IF;
    
    -- 权限检查过滤
    IF enable_permission_check THEN
        filtered_users := filter_users_by_permission(filtered_users);
        IF filtered_users IS NULL OR array_length(filtered_users,1) IS NULL THEN
            RETURN NULL;
        END IF;
    END IF;
    
    -- 社区优先推荐
    IF group_enable_comm_match AND enable_community_matching
       AND p_community IS NOT NULL THEN
        community_json := match_community_to_organization(p_community, filtered_users);
        community_matched_users := jsonb_to_bigint_array(community_json -> 'matched_users');
        
        IF community_matched_users IS NOT NULL
           AND array_length(community_matched_users,1) > 0 THEN
            filtered_users := community_matched_users;
        END IF;
    END IF;

    RETURN filtered_users;
END;
$$;

-- 3.2 统一的过滤器应用函数
CREATE OR REPLACE FUNCTION public.apply_allocation_filters (
    candidate_users           bigint[],
    group_id                  bigint,
    p_community               community,
    enable_quality_control    boolean,
    enable_community_matching boolean,
    enable_permission_check   boolean
) RETURNS bigint[]
LANGUAGE plpgsql
AS $$
DECLARE
    filtered_users          bigint[] := candidate_users;
    community_json          jsonb;
    community_matched_users bigint[];
    group_enable_quality    boolean;
    group_enable_comm_match boolean;
    dbg jsonb := jsonb_build_object(
        'input_users',                candidate_users,
        'group_id',                   group_id,
        'community',                  p_community,
        'enable_quality_control_arg', enable_quality_control,
        'enable_community_matching_arg', enable_community_matching,
        'enable_permission_check',    enable_permission_check
    );
BEGIN
    ------------------------------------------------------------------
    -- 0. 空数组直接返回
    ------------------------------------------------------------------
    IF filtered_users IS NULL OR array_length(filtered_users,1) IS NULL THEN
        dbg := dbg || '{"input_empty":true}';
        INSERT INTO simple_allocation_logs (leadid, processing_details)
        VALUES ('DEBUG_'||extract(epoch from now())::bigint,
                jsonb_build_object('apply_allocation_filters', dbg));
        RETURN NULL;
    END IF;

    ------------------------------------------------------------------
    -- 1. 读取用户组配置（加表别名避免歧义）
    ------------------------------------------------------------------
    SELECT 
        COALESCE(ul.enable_quality_control,    false),
        COALESCE(ul.enable_community_matching, false)
    INTO
        group_enable_quality,
        group_enable_comm_match
    FROM users_list ul
    WHERE ul.id = group_id;
    
    dbg := dbg || jsonb_build_object(
        'group_enable_quality',    group_enable_quality,
        'group_enable_comm_match', group_enable_comm_match
    );

    ------------------------------------------------------------------
    -- 2. 质量控制过滤
    ------------------------------------------------------------------
    IF group_enable_quality AND enable_quality_control THEN
        BEGIN
        filtered_users := filter_users_by_quality_control(filtered_users, group_id);
            dbg := dbg || jsonb_build_object('after_quality', filtered_users);

            IF filtered_users IS NULL OR array_length(filtered_users,1) IS NULL THEN
                dbg := dbg || '{"quality_filtered_all":true}';
                INSERT INTO simple_allocation_logs (leadid, processing_details)
                VALUES ('DEBUG_'||extract(epoch from now())::bigint,
                        jsonb_build_object('apply_allocation_filters', dbg));
            RETURN NULL;
        END IF;
        EXCEPTION WHEN OTHERS THEN
            dbg := dbg || jsonb_build_object('quality_error', SQLERRM);
        END;
    END IF;
    
    ------------------------------------------------------------------
    -- 3. 权限检查过滤
    ------------------------------------------------------------------
    IF enable_permission_check THEN
        BEGIN
        filtered_users := filter_users_by_permission(filtered_users);
            dbg := dbg || jsonb_build_object('after_permission', filtered_users);

            IF filtered_users IS NULL OR array_length(filtered_users,1) IS NULL THEN
                dbg := dbg || '{"permission_filtered_all":true}';
                INSERT INTO simple_allocation_logs (leadid, processing_details)
                VALUES ('DEBUG_'||extract(epoch from now())::bigint,
                        jsonb_build_object('apply_allocation_filters', dbg));
            RETURN NULL;
        END IF;
        EXCEPTION WHEN OTHERS THEN
            dbg := dbg || jsonb_build_object('permission_error', SQLERRM);
        END;
    END IF;
    
    ------------------------------------------------------------------
    -- 4. 社区优先推荐
    ------------------------------------------------------------------
    IF group_enable_comm_match AND enable_community_matching
       AND p_community IS NOT NULL THEN
        BEGIN
            community_json := match_community_to_organization(p_community,
                                                              filtered_users);
            community_matched_users :=
                jsonb_to_bigint_array(community_json -> 'matched_users');

            dbg := dbg || jsonb_build_object(
                'community_json',      community_json,
                'community_matched',   community_matched_users
            );
        
            IF community_matched_users IS NOT NULL
               AND array_length(community_matched_users,1) > 0 THEN
            filtered_users := community_matched_users;
        END IF;
        EXCEPTION WHEN OTHERS THEN
            dbg := dbg || jsonb_build_object('community_match_error', SQLERRM);
        END;
    END IF;
    
    ------------------------------------------------------------------
    -- 5. 写入最终日志并返回
    ------------------------------------------------------------------
    dbg := dbg || jsonb_build_object(
        'final_users', filtered_users,
        'final_cnt',   COALESCE(array_length(filtered_users,1),0)
    );

    INSERT INTO simple_allocation_logs (leadid, processing_details)
    VALUES ('DEBUG_'||extract(epoch from now())::bigint,
            jsonb_build_object('apply_allocation_filters', dbg));

    RETURN filtered_users;
END;
$$;

-- 修改 allocate_from_users 函数
CREATE OR REPLACE FUNCTION public.allocate_from_users(
    user_list bigint[],
    method allocation_method
) RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
    target_user_id bigint;
BEGIN
    -- 如果用户列表为空，返回NULL
    IF user_list IS NULL OR array_length(user_list, 1) IS NULL THEN
        RETURN NULL;
    END IF;
    
    CASE method
        WHEN 'round_robin' THEN
            -- 轮流分配：选择今日分配数量最少的用户
            SELECT user_id INTO target_user_id
            FROM unnest(user_list) AS user_id
            ORDER BY (
                SELECT COUNT(*) FROM simple_allocation_logs sal
                WHERE sal.assigned_user_id = user_id::bigint
                AND sal.created_at >= CURRENT_DATE
            ) ASC, RANDOM()
            LIMIT 1;
            
        WHEN 'random' THEN
            -- 随机分配
            SELECT user_id INTO target_user_id
            FROM unnest(user_list) AS user_id
            ORDER BY RANDOM()
            LIMIT 1;
            
        WHEN 'workload' THEN
            -- 按工作量分配
            SELECT user_id INTO target_user_id
            FROM unnest(user_list) AS user_id
            ORDER BY (
                SELECT COUNT(*) FROM simple_allocation_logs sal
                WHERE sal.assigned_user_id = user_id::bigint
                AND sal.created_at >= CURRENT_DATE - INTERVAL '7 days'
            ) ASC, RANDOM()
            LIMIT 1;
            
        ELSE
            -- 默认取第一个用户
            SELECT user_id INTO target_user_id
            FROM unnest(user_list) AS user_id
            LIMIT 1;
    END CASE;
    
    RETURN target_user_id;
END;
$$;

-- 修改 get_group_users 函数
CREATE OR REPLACE FUNCTION public.get_group_users(group_id bigint)
RETURNS bigint[]
LANGUAGE plpgsql
AS $$
DECLARE
    user_list bigint[];
    raw_list text[];
BEGIN
    SELECT list INTO raw_list
    FROM users_list
    WHERE id = group_id AND list IS NOT NULL;
    
    -- 如果list是字符串数组，转换为数字数组
    IF raw_list IS NOT NULL THEN
        SELECT array_agg(element::bigint) INTO user_list
        FROM unnest(raw_list) element;
    END IF;
    
    RETURN user_list;
END;
$$;

-- 3.5 获取默认用户
CREATE OR REPLACE FUNCTION public.get_default_user()
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
    default_user_id bigint;
BEGIN
    SELECT id INTO default_user_id
    FROM users_profile
    WHERE status = 'active'
    ORDER BY updated_at ASC
    LIMIT 1;
    
    RETURN default_user_id;
END;
$$;

-- 3.6 时间条件检查
CREATE OR REPLACE FUNCTION public.check_time_condition(time_config jsonb)
RETURNS boolean
LANGUAGE plpgsql
AS $$
DECLARE
    current_time time := CURRENT_TIME;
    current_weekday integer := EXTRACT(DOW FROM CURRENT_DATE);
    start_time time;
    end_time time;
    weekdays integer[];
BEGIN
    -- 检查工作日
    IF time_config ? 'weekdays' THEN
        weekdays := ARRAY(SELECT jsonb_array_elements_text(time_config->'weekdays'))::integer[];
        IF NOT (current_weekday = ANY(weekdays)) THEN
            RETURN false;
        END IF;
    END IF;
    
    -- 检查时间范围
    IF time_config ? 'start' AND time_config ? 'end' THEN
        start_time := (time_config->>'start')::time;
        end_time := (time_config->>'end')::time;
        RETURN current_time BETWEEN start_time AND end_time;
    END IF;
    
    RETURN true;
END;
$$;

-- =====================================
-- 4. 简化的触发器
-- =====================================

-- 修复触发器函数
CREATE OR REPLACE FUNCTION public.simple_lead_allocation_trigger()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, pg_temp
AS $$
DECLARE
    allocation_result jsonb;
    target_user_id bigint;
    duplicate_count integer;
    lead_community community;
    debug_info jsonb := '{}';
BEGIN
    -- 检查过去7天内是否有重复的phone或wechat
    SELECT COUNT(*) INTO duplicate_count
    FROM public.leads l
    WHERE (
            (NEW.phone IS NOT NULL AND NEW.phone != '' AND l.phone = NEW.phone) OR
            (NEW.wechat IS NOT NULL AND NEW.wechat != '' AND l.wechat = NEW.wechat)
    )
    AND l.created_at >= NOW() - INTERVAL '7 days'
    AND l.leadid != NEW.leadid;  -- 排除当前记录
    
    -- 如果发现重复，记录日志并返回
    IF duplicate_count > 0 THEN
        INSERT INTO simple_allocation_logs (
            leadid,
            processing_details
        ) VALUES (
            NEW.leadid,
            jsonb_build_object(
                'duplicate_found', true,
                'duplicate_count', duplicate_count,
                'check_time', NOW()
            )
        );
        RETURN NEW;
    END IF;
    
    -- 优先从remark中提取community信息
    IF NEW.remark IS NOT NULL AND NEW.remark ~ '\[COMMUNITY:([^\]]+)\]' THEN
        SELECT (regexp_match(NEW.remark, '\[COMMUNITY:([^\]]+)\]'))[1]::community INTO lead_community;
        debug_info := debug_info || jsonb_build_object('community_from_remark', lead_community);
    END IF;
    
    -- 如果remark中没有community信息，则从广告信息动态推导
    IF lead_community IS NULL THEN
        SELECT community INTO lead_community
        FROM community_keywords
        WHERE EXISTS (
          SELECT 1 FROM unnest(keyword) AS k
          WHERE
            (NEW.campaignname ILIKE '%' || k || '%'
             OR NEW.unitname ILIKE '%' || k || '%'
             OR NEW.remark ILIKE '%' || k || '%')
        )
        ORDER BY priority DESC
        LIMIT 1;
        
        IF lead_community IS NOT NULL THEN
            debug_info := debug_info || jsonb_build_object('community_from_keywords', lead_community);
        END IF;
    END IF;
    
    -- 如果仍然没有匹配到，使用默认值
    IF lead_community IS NULL THEN
        SELECT enumlabel::community INTO lead_community
        FROM pg_enum 
        WHERE enumtypid = 'community'::regtype 
        ORDER BY enumsortorder 
        LIMIT 1;
        debug_info := debug_info || jsonb_build_object('community_default', lead_community);
    END IF;
    
    -- 执行分配
    BEGIN
        allocation_result := allocate_lead_simple(
            NEW.leadid,
            NEW.source,
            NEW.leadtype,
            lead_community,
            NULL  -- 手动分配用户
        );
        
        -- 获取分配结果
        IF allocation_result IS NOT NULL AND (allocation_result->>'success')::boolean THEN
            target_user_id := (allocation_result->>'assigned_user_id')::bigint;
            
            -- 创建followups记录
            IF target_user_id IS NOT NULL THEN
                -- 检查用户是否存在
                IF NOT EXISTS (SELECT 1 FROM public.users_profile WHERE id = target_user_id) THEN
                    RAISE EXCEPTION '用户ID % 不存在', target_user_id;
                END IF;
                
                -- 检查leadid是否已存在followups记录
                IF NOT EXISTS (SELECT 1 FROM public.followups WHERE leadid = NEW.leadid) THEN
                    INSERT INTO public.followups (
                        leadid, 
                        leadtype, 
                        followupstage, 
                        interviewsales_user_id,
                        created_at, 
                        updated_at
                    ) VALUES (
                        NEW.leadid, 
                        NEW.leadtype, 
                        '待接收', 
                        target_user_id,
                        NOW(), 
                        NOW()
                    );
                END IF;
            END IF;
        ELSE
            -- 记录分配失败的情况
            INSERT INTO simple_allocation_logs (
                leadid,
                processing_details
            ) VALUES (
                NEW.leadid,
                jsonb_build_object(
                    'allocation_failed', true,
                    'error_details', allocation_result,
                    'debug_info', debug_info
                )
            );
        END IF;
    EXCEPTION WHEN OTHERS THEN
        -- 记录异常情况
        INSERT INTO simple_allocation_logs (
            leadid,
            processing_details
        ) VALUES (
            NEW.leadid,
            jsonb_build_object(
                'error', SQLERRM,
                'error_detail', SQLSTATE,
                'debug_info', debug_info
            )
        );
    END;
    
    RETURN NEW;
END;
$$;

-- =====================================
-- 5. 管理函数
-- =====================================

-- 5.1 创建简化规则
CREATE OR REPLACE FUNCTION public.create_simple_allocation_rule(
    p_name text,
    p_description text DEFAULT NULL,
    p_user_groups bigint[] DEFAULT NULL,
    p_conditions jsonb DEFAULT '{}',
    p_allocation_method allocation_method DEFAULT 'round_robin',
    p_enable_permission_check boolean DEFAULT false,
    p_priority integer DEFAULT 0
) RETURNS uuid
LANGUAGE plpgsql
AS $$
DECLARE
    rule_id uuid;
BEGIN
    INSERT INTO simple_allocation_rules (
        name, description, user_groups, conditions, allocation_method,
        enable_permission_check, priority
    ) VALUES (
        p_name, p_description, p_user_groups, p_conditions, p_allocation_method,
        p_enable_permission_check, p_priority
    ) RETURNING id INTO rule_id;
    
    RETURN rule_id;
END;
$$;

-- 5.2 分配统计视图
CREATE OR REPLACE VIEW public.simple_allocation_stats AS
SELECT 
    r.name as rule_name,
    COUNT(*) as total_allocations,
    COUNT(DISTINCT l.assigned_user_id) as unique_users,
    AVG(l.selected_group_index) as avg_group_index,
    COUNT(*) FILTER (WHERE l.selected_group_index = 1) as first_group_success,
    ROUND(
        COUNT(*) FILTER (WHERE l.selected_group_index = 1)::numeric / 
        COUNT(*)::numeric * 100, 2
    ) as first_group_success_rate,
    MIN(l.created_at) as first_allocation,
    MAX(l.created_at) as last_allocation
FROM simple_allocation_logs l
JOIN simple_allocation_rules r ON l.rule_id = r.id
GROUP BY r.id, r.name
ORDER BY total_allocations DESC;

-- =====================================
-- 6. 优化后的配置示例
-- =====================================

-- 6.1 创建示例用户组数据（如果不存在）
-- 使用 INSERT ... WHERE NOT EXISTS 避免 ON CONFLICT 约束问题
INSERT INTO users_list (
    groupname, list, description, allocation,
    enable_quality_control, enable_community_matching,
    daily_lead_limit, conversion_rate_requirement, max_pending_leads
)
SELECT 
    '高级销售组', 
    ARRAY[]::bigint[], -- 空数组，需要后续配置用户ID
    '高级销售团队，有严格的质量控制要求', 
    'round_robin'::allocation_method,
    true, true,
    20, 5.0, 5
WHERE NOT EXISTS (SELECT 1 FROM users_list WHERE groupname = '高级销售组')

UNION ALL

SELECT 
    '新手销售组', 
    ARRAY[]::bigint[], -- 空数组，需要后续配置用户ID
    '新手销售团队，较宽松的质量控制', 
    'workload'::allocation_method,
    true, false,
    15, 3.0, 8
WHERE NOT EXISTS (SELECT 1 FROM users_list WHERE groupname = '新手销售组')

UNION ALL

SELECT 
    '默认销售组', 
    ARRAY[]::bigint[], -- 空数组，需要后续配置用户ID
    '默认销售组，无特殊限制', 
    'random'::allocation_method,
    false, false,
    NULL, NULL, NULL
WHERE NOT EXISTS (SELECT 1 FROM users_list WHERE groupname = '默认销售组');

-- 6.2 创建简化的分配规则示例
SELECT create_simple_allocation_rule(
    '默认分配规则',
    '所有线索的默认分配规则',
    ARRAY[1, 2, 3], -- 用户组ID数组，按优先级顺序
    '{"time_ranges": {"weekdays": [1,2,3,4,5], "start": "09:00", "end": "18:00"}}',
    'round_robin'::allocation_method,
    false, -- 权限检查
    100 -- 优先级
);

-- 6.3 查看优化后的分配统计
SELECT * FROM simple_allocation_stats ORDER BY total_allocations DESC;

-- =====================================
-- 7. 创建触发器
-- =====================================

-- 创建简化的分配触发器
DROP TRIGGER IF EXISTS trg_simple_lead_allocation ON public.leads;

-- 创建AFTER INSERT触发器
CREATE TRIGGER trg_simple_lead_allocation
AFTER INSERT ON public.leads
FOR EACH ROW
EXECUTE FUNCTION simple_lead_allocation_trigger();

-- 创建触发器：自动更新simple_allocation_rules的updated_at
CREATE OR REPLACE FUNCTION public.update_simple_allocation_rules_timestamp()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
    NEW.updated_at := NOW();
    RETURN NEW;
END;
$$;

CREATE TRIGGER trg_simple_allocation_rules_updated
BEFORE UPDATE ON public.simple_allocation_rules
FOR EACH ROW
EXECUTE FUNCTION update_simple_allocation_rules_timestamp();

-- 创建用户ID验证触发器函数
CREATE OR REPLACE FUNCTION public.check_users_profile_ids()
RETURNS trigger
LANGUAGE plpgsql
AS $$
DECLARE
    invalid_ids bigint[];
BEGIN
    -- 如果 list 字段为空或NULL，直接返回
    IF NEW.list IS NULL OR array_length(NEW.list, 1) IS NULL THEN
        RETURN NEW;
    END IF;
    
    -- 检查 list 数组中的每个 ID 是否存在于 users_profile 表中
    SELECT array_agg(id) INTO invalid_ids
    FROM unnest(NEW.list) AS id
    WHERE NOT EXISTS (
        SELECT 1 FROM public.users_profile 
        WHERE users_profile.id = id
    );
    
    -- 如果有无效的用户 ID，抛出异常
    IF invalid_ids IS NOT NULL AND array_length(invalid_ids, 1) > 0 THEN
        RAISE EXCEPTION '无效的用户ID: %', array_to_string(invalid_ids, ', ');
    END IF;
    
    -- 更新 updated_at 时间戳
    NEW.updated_at := NOW();
    
    RETURN NEW;
END;
$$;

-- 创建用户ID验证触发器
CREATE TRIGGER check_users_profile_ids_trigger 
BEFORE INSERT OR UPDATE ON public.users_list 
FOR EACH ROW
EXECUTE FUNCTION check_users_profile_ids();

-- =====================================
-- 8. 辅助函数（质量控制相关）
-- =====================================

-- 8.1 权限检查过滤函数（如果需要）
CREATE OR REPLACE FUNCTION public.filter_users_by_permission(user_ids bigint[])
RETURNS bigint[]
LANGUAGE plpgsql
AS $$
DECLARE
    filtered_users bigint[] := ARRAY[]::bigint[];
    user_id bigint;
BEGIN
    -- 如果没有启用权限检查，返回所有用户
    IF user_ids IS NULL OR array_length(user_ids, 1) IS NULL THEN
        RETURN user_ids;
    END IF;
    
    -- 检查每个用户是否有分配权限
    FOREACH user_id IN ARRAY user_ids LOOP
        -- 简化的权限检查：检查用户是否处于活跃状态
        IF EXISTS (
            SELECT 1 FROM users_profile 
            WHERE id = user_id AND status = 'active'
        ) THEN
            filtered_users := filtered_users || user_id;
        END IF;
    END LOOP;
    
    RETURN filtered_users;
END;
$$;

-- 8.2 社区匹配函数
CREATE OR REPLACE FUNCTION public.match_community_to_organization(p_community community, user_ids bigint[])
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    matched_users bigint[];
BEGIN
    /* ---------- 递归向上查找用户所属部门链并比对社区 ---------- */
    WITH RECURSIVE org_chain AS (          -- ① 基础 + 递归
        /* 锚点：用户所在的直接部门 */
        SELECT up.id AS uid,
               up.organization_id AS org_id
        FROM   users_profile up
        WHERE  up.id = ANY(user_ids)

        UNION ALL

        /* 向上递归 parent_id，直到根部门 */
        SELECT oc.uid,
               o.parent_id AS org_id
        FROM   org_chain oc
        JOIN   organizations o ON o.id = oc.org_id
        WHERE  o.parent_id IS NOT NULL
    ),
    matched AS (                           -- ② 过滤社区匹配
        SELECT DISTINCT oc.uid
        FROM   org_chain oc
        JOIN   organizations o
               ON o.id = oc.org_id
              AND o.name = p_community::text   -- ← 关键比较：部门名 = 目标社区
    )
    SELECT array_agg(uid) INTO matched_users  -- ③ 聚合为 bigint[]
    FROM   matched;

    /* 若无人匹配，返回空数组 */
    IF matched_users IS NULL THEN
        matched_users := ARRAY[]::bigint[];
    END IF;

    RETURN jsonb_build_object(
        'matched_users', matched_users,
        'community',     p_community,
        'matched_count', COALESCE(array_length(matched_users,1),0)
    );
END;
$function$

-- =====================================
-- 9. 数据完整性检查
-- =====================================

-- 9.2 创建质量控制函数（如果不存在）
CREATE OR REPLACE FUNCTION public.filter_users_by_quality_control(
    p_user_ids bigint[],
    p_group_id bigint
) RETURNS bigint[]
LANGUAGE plpgsql
AS $$
DECLARE
    eligible_users bigint[] := ARRAY[]::bigint[];
    user_id bigint;
    group_config RECORD;
    daily_assigned integer;
    pending_count integer;
    conversion_rate numeric;
    user_stats jsonb;
BEGIN
    -- 获取用户组质量控制配置
    SELECT 
        ul.enable_quality_control,
        ul.daily_lead_limit,
        ul.conversion_rate_requirement,
        ul.max_pending_leads
    INTO group_config
    FROM users_list ul
    WHERE ul.id = p_group_id;
    
    -- 如果未启用质量控制，直接返回所有用户
    IF NOT COALESCE(group_config.enable_quality_control, false) THEN
        RETURN p_user_ids;
    END IF;
    
    -- 遍历用户ID数组，检查每个用户的质量控制条件
    FOREACH user_id IN ARRAY p_user_ids LOOP
        -- 检查日线索量限制
        SELECT COUNT(*) INTO daily_assigned
        FROM simple_allocation_logs
        WHERE assigned_user_id = user_id
          AND created_at >= CURRENT_DATE;
        
        IF group_config.daily_lead_limit IS NOT NULL AND daily_assigned >= group_config.daily_lead_limit THEN
            CONTINUE;
        END IF;
        
        -- 检查未接受线索数量
        SELECT COUNT(*) INTO pending_count
        FROM followups
        WHERE interviewsales_user_id = user_id
          AND followupstage = '待接收';
        
        IF group_config.max_pending_leads IS NOT NULL AND pending_count > group_config.max_pending_leads THEN
            CONTINUE;
        END IF;
        
        -- 检查转化率（简化版本）
        IF group_config.conversion_rate_requirement IS NOT NULL THEN
            -- 计算简化的转化率
            WITH user_stats AS (
                SELECT 
                    COUNT(*) as total_leads,
                    COUNT(*) FILTER (WHERE followupstage IN ('赢单')) as converted_leads
                FROM followups
                WHERE interviewsales_user_id = user_id
                  AND created_at >= CURRENT_DATE - INTERVAL '30 days'
            )
            SELECT 
                CASE 
                    WHEN total_leads >= 50 THEN 
                        ROUND((converted_leads::numeric / total_leads::numeric) * 100, 2)
                    ELSE 
                        group_config.conversion_rate_requirement -- 样本不足时通过检查
                END
            INTO conversion_rate
            FROM user_stats;
            
            IF conversion_rate < group_config.conversion_rate_requirement THEN
                CONTINUE;
            END IF;
        END IF;
        
        -- 通过所有检查，添加到可用用户列表
        eligible_users := eligible_users || user_id;
    END LOOP;
    
    RETURN eligible_users;
END;
$$;


-- 9.4 创建索引优化查询性能
CREATE INDEX IF NOT EXISTS idx_simple_allocation_logs_user_date 
ON simple_allocation_logs(assigned_user_id, created_at);

CREATE INDEX IF NOT EXISTS idx_simple_allocation_logs_leadid 
ON simple_allocation_logs(leadid);

CREATE INDEX IF NOT EXISTS idx_simple_allocation_rules_active 
ON simple_allocation_rules(is_active, priority) WHERE is_active = true;

CREATE INDEX IF NOT EXISTS idx_followups_user_stage 
ON followups(interviewsales_user_id, followupstage);

CREATE INDEX IF NOT EXISTS idx_followups_created_at 
ON followups(created_at);

CREATE INDEX IF NOT EXISTS idx_leads_phone_wechat_created 
ON leads(phone, wechat, created_at);

-- 9.5 创建权限表和权限记录
-- 首先确保permissions表存在
CREATE TABLE IF NOT EXISTS public.permissions (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    name text NOT NULL,
    description text NULL,
    resource text NOT NULL,
    action text NOT NULL,
    created_at timestamp with time zone NULL DEFAULT now(),
    updated_at timestamp with time zone NULL DEFAULT now(),
    CONSTRAINT permissions_pkey PRIMARY KEY (id),
    CONSTRAINT permissions_name_key UNIQUE (name),
    CONSTRAINT permissions_resource_action_key UNIQUE (resource, action)
) TABLESPACE pg_default;

-- 如果表已存在，确保约束也存在
DO $$
BEGIN
    -- 添加resource, action的唯一约束（如果不存在）
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.table_constraints 
        WHERE constraint_name = 'permissions_resource_action_key' 
        AND table_name = 'permissions'
        AND table_schema = 'public'
    ) THEN
        -- 检查是否有重复数据
        IF NOT EXISTS (
            SELECT resource, action FROM permissions 
            GROUP BY resource, action 
            HAVING COUNT(*) > 1
        ) THEN
            ALTER TABLE public.permissions 
            ADD CONSTRAINT permissions_resource_action_key UNIQUE (resource, action);
            RAISE NOTICE '已添加 permissions (resource, action) 唯一约束';
        ELSE
            RAISE NOTICE '警告：permissions 表中存在重复的 (resource, action) 值，无法添加唯一约束';
        END IF;
    ELSE
        RAISE NOTICE 'permissions (resource, action) 唯一约束已存在';
    END IF;
END $$;

-- 插入权限数据
-- 使用 INSERT ... WHERE NOT EXISTS 避免 ON CONFLICT 约束问题
INSERT INTO permissions (name, resource, action, description)
SELECT 
    'simple_allocation_view', 'simple_allocation', 'view', '查看分配统计'
WHERE NOT EXISTS (
    SELECT 1 FROM permissions 
    WHERE resource = 'simple_allocation' AND action = 'view'
)

UNION ALL

SELECT 
    'simple_allocation_manage', 'simple_allocation', 'manage', '管理分配规则'
WHERE NOT EXISTS (
    SELECT 1 FROM permissions 
    WHERE resource = 'simple_allocation' AND action = 'manage'
);

-- =====================================
-- 10. 数据完整性检查和验证
-- =====================================

-- 10.1 检查脚本执行后的数据完整性
CREATE OR REPLACE FUNCTION public.validate_allocation_system()
RETURNS jsonb
LANGUAGE plpgsql
AS $$
DECLARE
    result jsonb := '{}';
    active_users_count integer;
    user_groups_count integer;
    allocation_rules_count integer;
BEGIN
    -- 检查活跃用户数量
    SELECT COUNT(*) INTO active_users_count
    FROM users_profile
    WHERE status = 'active';
    
    -- 检查用户组数量
    SELECT COUNT(*) INTO user_groups_count
    FROM users_list
    WHERE list IS NOT NULL AND array_length(list, 1) > 0;
    
    -- 检查分配规则数量
    SELECT COUNT(*) INTO allocation_rules_count
    FROM simple_allocation_rules
    WHERE is_active = true;
    
    -- 构建结果
    result := jsonb_build_object(
        'active_users', active_users_count,
        'user_groups', user_groups_count,
        'allocation_rules', allocation_rules_count,
        'system_ready', (active_users_count > 0 AND user_groups_count > 0 AND allocation_rules_count > 0),
        'validation_time', NOW()
    );
    
    RETURN result;
END;
$$;

-- 10.2 测试分配功能
CREATE OR REPLACE FUNCTION public.test_allocation_system()
RETURNS jsonb
LANGUAGE plpgsql
AS $$
DECLARE
    test_result jsonb;
    test_leadid text;
BEGIN
    -- 创建测试线索ID
    test_leadid := 'TEST_' || EXTRACT(EPOCH FROM NOW())::bigint;
    
    -- 测试分配功能
    SELECT allocate_lead_simple(
        test_leadid,
        '抖音'::source,
        '意向客户',
        '万科城市花园'::community,
        NULL
    ) INTO test_result;
    
    RETURN jsonb_build_object(
        'test_leadid', test_leadid,
        'allocation_result', test_result,
        'test_time', NOW()
    );
END;
$$;

-- =====================================
-- 11. 添加必要的辅助函数
-- =====================================

-- 11.1 获取枚举类型值列表函数
CREATE OR REPLACE FUNCTION public.get_enum_values(enum_name text)
RETURNS text[]
LANGUAGE plpgsql
AS $$
DECLARE
  values text[];
BEGIN
  EXECUTE format(
    'SELECT array_agg(enumlabel ORDER BY enumsortorder) FROM pg_enum WHERE enumtypid = %L::regtype',
    enum_name
  ) INTO values;
  
  RETURN values;
END;
$$;

-- 执行系统验证
SELECT public.validate_allocation_system() AS system_validation;